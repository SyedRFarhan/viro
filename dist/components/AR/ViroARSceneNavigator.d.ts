/**
 * Copyright (c) 2017-present, Viro Media, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ViroARSceneNavigator
 * @flow
 */
import * as React from "react";
import { ViewProps } from "react-native";
import { ViroWorldOrigin, ViroCloudAnchorProvider, ViroCloudAnchorStateChangeEvent, ViroHostCloudAnchorResult, ViroResolveCloudAnchorResult, ViroGeospatialAnchorProvider, ViroGeospatialSupportResult, ViroEarthTrackingStateResult, ViroGeospatialPoseResult, ViroVPSAvailabilityResult, ViroCreateGeospatialAnchorResult, ViroQuaternion, ViroSemanticSupportResult, ViroSemanticLabelFractionsResult, ViroSemanticLabelFractionResult, ViroSemanticLabel, ViroMonocularDepthSupportResult, ViroMonocularDepthModelDownloadedResult, ViroMonocularDepthDownloadResult, ViroMonocularDepthPreferenceResult, ViroRenderZoomResult, ViroMaxRenderZoomResult } from "../Types/ViroEvents";
import { Viro3DPoint, ViroNativeRef, ViroScene, ViroSceneDictionary } from "../Types/ViroUtils";
import { ViroWorldMeshConfig, ViroWorldMeshStats } from "../Types/ViroWorldMesh";
import { ViroWorldMapPersistenceEvent, ViroSaveWorldMapResult } from "../Types/ViroWorldMap";
/**
 * Occlusion mode determines how virtual content is occluded by real-world objects.
 */
export type ViroOcclusionMode = "disabled" | "depthBased" | "peopleOnly";
type Props = ViewProps & {
    /**
     * ViroARSceneNavigator uses "scene" objects like the following to
     * describe a scene.
     */
    initialScene: {
        /**
         * The React Class to render for this scene.
         */
        scene: () => React.JSX.Element;
    };
    initialSceneKey?: string;
    autofocus?: boolean;
    /**
     * iOS only props! Note: these props may change as the underlying platforms coalesce in features.
     */
    worldAlignment?: "Gravity" | "GravityAndHeading" | "Camera";
    videoQuality?: "High" | "Low";
    numberOfTrackedImages?: number;
    viroAppProps?: any;
    /**
     * Renderer settings that can be used to enable or disable various
     * renderer capabilities and algorithms.
     */
    hdrEnabled?: boolean;
    pbrEnabled?: boolean;
    bloomEnabled?: boolean;
    shadowsEnabled?: boolean;
    multisamplingEnabled?: boolean;
    /**
     * Enable AR occlusion so real-world objects properly hide virtual content.
     * Requires a device with depth sensing capability.
     *
     * @default "disabled"
     */
    occlusionMode?: ViroOcclusionMode;
    /**
     * [Debug] Enable depth debug visualization to see how the depth texture is being sampled.
     * When enabled, the camera background will show a color overlay representing depth values:
     * - Magenta = No depth data
     * - Red = Very close (0-1m)
     * - Yellow = Medium (1-3m)
     * - Green = Medium-far (3-5m)
     * - Cyan = Far (5-10m)
     * - Blue = Very far (10m+)
     *
     * @default false
     */
    depthDebugEnabled?: boolean;
    /**
     * Enable cloud anchors for cross-platform anchor sharing.
     * When set to 'arcore', the ARCore Cloud Anchors SDK will be used.
     * Requires a valid Google Cloud API key configured in the native project.
     *
     * @default "none"
     * @platform ios,android
     */
    cloudAnchorProvider?: ViroCloudAnchorProvider;
    /**
     * Callback fired when a cloud anchor state changes.
     * This includes progress updates during hosting/resolving operations.
     */
    onCloudAnchorStateChange?: (event: ViroCloudAnchorStateChangeEvent) => void;
    /**
     * Enable the ARCore Geospatial API for location-based AR experiences.
     * When set to 'arcore', the ARCore Geospatial SDK will be used.
     * Requires a valid Google Cloud API key configured in the native project.
     *
     * @default "none"
     * @platform ios,android
     */
    geospatialAnchorProvider?: ViroGeospatialAnchorProvider;
    /**
     * Enable world mesh for physics collision with real-world surfaces.
     * When enabled, virtual physics objects will collide with detected
     * real-world geometry (floors, walls, tables, etc.).
     *
     * Requires depth sensing capability:
     * - iOS: LiDAR scanner (iPhone 12 Pro+, iPad Pro 2020+)
     * - Android: ToF sensor or ARCore Depth API support
     *
     * @default false
     * @platform ios,android
     */
    worldMeshEnabled?: boolean;
    /**
     * Configuration for world mesh generation and physics properties.
     * Only used when worldMeshEnabled is true.
     */
    worldMeshConfig?: ViroWorldMeshConfig;
    /**
     * Callback fired when the world mesh is updated.
     * Provides statistics about the current mesh state.
     */
    onWorldMeshUpdated?: (stats: ViroWorldMeshStats) => void;
    /**
     * [iOS Only] Session persistence identifier.
     * When provided, ViroReact will automatically:
     * - Save the AR world map periodically and when app goes to background
     * - Load and restore the world map when remounting with the same sessionId
     *
     * This enables AR session continuity across component lifecycle.
     */
    sessionId?: string;
    /**
     * [iOS Only] Auto-save interval in seconds for world map persistence.
     * Only used when sessionId is set.
     * Set to 0 to disable auto-save (manual save only via saveWorldMap()).
     * @default 30
     */
    worldMapAutoSaveInterval?: number;
    /**
     * [iOS Only] Callback fired when world map persistence status changes.
     * Useful for showing UI feedback during save/load operations.
     */
    onWorldMapPersistenceStatus?: (event: ViroWorldMapPersistenceEvent) => void;
};
type State = {
    sceneDictionary: ViroSceneDictionary;
    sceneHistory: string[];
    currentSceneIndex: number;
};
/**
 * ViroARSceneNavigator is used to transition between multiple AR Scenes.
 */
export declare class ViroARSceneNavigator extends React.Component<Props, State> {
    _component: ViroNativeRef;
    constructor(props: Props);
    componentWillUnmount(): void;
    /**
     * Starts recording video of the Viro renderer and external audio
     *
     * @param fileName - name of the file (without extension)
     * @param saveToCameraRoll - whether or not the file should also be saved to the camera roll
     * @param onError - callback function that accepts an errorCode.
     */
    _startVideoRecording: (fileName: string, saveToCameraRoll: boolean, onError: (errorCode: number) => void) => void;
    /**
     * Stops recording the video of the Viro Renderer.
     *
     * returns Object w/ success, url and errorCode keys.
     * @returns Promise that resolves when the video has stopped recording.
     */
    _stopVideoRecording: () => Promise<any>;
    /**
     * Takes a screenshot of the Viro renderer
     *
     * @param fileName - name of the file (without extension)
     * @param saveToCameraRoll - whether or not the file should also be saved to the camera roll
     * returns Object w/ success, url and errorCode keys.
     */
    _takeScreenshot: (fileName: string, saveToCameraRoll: boolean) => Promise<any>;
    /**
     * Takes a high-resolution photo using ARKit's captureHighResolutionFrame (iOS 16+).
     * This captures the camera image at full sensor resolution (up to 12MP) with
     * the 3D scene composited on top.
     *
     * @param fileName - name of the file (without extension)
     * @param saveToCameraRoll - whether or not the file should also be saved to the camera roll
     * @returns Object with success, url, and errorCode keys.
     *          errorCode: 0=success, 1=no permissions, 5=write failed,
     *                     10=iOS<16 not supported, 11=capture failed, 15=session not ready
     */
    _takeHighResolutionPhoto: (fileName: string, saveToCameraRoll: boolean) => Promise<any>;
    /**
     * @todo document _project
     *
     * @param point
     * @returns
     */
    _project: (point: Viro3DPoint) => Promise<any>;
    /**
     * TODO: Document _unproject
     *
     * @param point
     * @returns
     */
    _unproject: (point: Viro3DPoint) => Promise<any>;
    /**
     * Gets a random tag string.
     *
     * @returns a random tag.
     */
    getRandomTag: () => string;
    /**
     * Pushes a scene and reference it with the given key if provided.
     * If the scene has been previously pushed, we simply show the scene again.
     * Note that the back history order of which scenes were pushed is preserved.
     * Also note that scenes are reference counted and only a unique set of
     * scenes are stored and mapped to within sceneDictionary.
     *
     * Can take in either 1 or two parameters in the form:
     * push ("sceneKey");
     * push ("sceneKey", scene);
     * push (scene);
     *
     * @todo use Typescript function overloading rather than this inaccurate solution
     * @todo document parameters
     */
    push: (param1?: ViroScene | string, param2?: ViroScene) => void;
    /**
     * Replace the top scene in the stack with the given scene. The remainder of the back
     * history is kept in the same order as before.
     *
     * Can take in either 1 or two parameters in the form:
     * replace ("sceneKey");
     * replace ("sceneKey", scene);
     * replace (scene);
     *
     * @todo use Typescript function overloading rather than this inaccurate solution
     * @todo document parameters
     */
    replace: (param1?: ViroScene | string, param2?: ViroScene) => void;
    /**
     * Jumps to a given scene that had been previously pushed. If the scene was not pushed, we
     * then push and jump to it. The back history is re-ordered such that jumped to scenes are
     * re-ordered to the front. As such, only the back order of sequential jumps are preserved.
     *
     * Can take in either 1 or two parameters in the form:
     * jump ("sceneKey");
     * jump ("sceneKey", scene);
     * jump (scene);
     *
     * @todo use Typescript function overloading rather than this inaccurate solution
     * @todo document parameters
     */
    jump: (param1?: ViroScene | string, param2?: ViroScene) => void;
    /**
     * Pop 1 screen from the stack.
     */
    pop: () => void;
    /**
     * Pop n screens from the stack.
     *
     * @param n number of scenes to pop
     * @returns void
     */
    popN: (n: number) => void;
    /**
     * Increments the reference count for a scene within sceneDictionary that is
     * mapped to the given sceneKey. If no scenes are found / mapped, we create
     * one, initialize it with a reference count of 1, and store it within the
     * sceneDictionary for future reference.
     *
     * @todo TODO: Document parameters.
     */
    incrementSceneReference: (scene: ViroScene, sceneKey: string, limitOne: boolean) => void;
    /**
     * Decrements the reference count for the last N scenes within
     * the sceneHistory by 1. If nothing else references that given scene
     * (counts equals 0), we then remove that scene from sceneDictionary.
     *
     * @param n number to decrement by.
     */
    decrementReferenceForLastNScenes: (n: number) => void;
    /**
     * Adds the given sceneKey to the sceneHistory and updates the currentSceneIndex to point
     * to the scene on the top of the history stack (the most recent scene).
     *
     * @param sceneKey scene to insert into the stack.
     */
    addToHistory: (sceneKey: string) => void;
    /**
     * Instead of preserving history, we find the last pushed sceneKey within the history stack
     * matching the given sceneKey and re-order it to the front. We then update the
     * currentSceneIndex to point to the scene on the top of the history stack
     * (the most recent scene).
     *
     * @param sceneKey scene to put at the top of the stack.
     */
    reorderHistory: (sceneKey: string) => void;
    /**
     * Pops the history entries by n screens.
     *
     * @param n number of history entries to pop.
     */
    popHistoryByN(n: number): void;
    /**
     * Gets the index of a scene by the scene tag.
     *
     * @param sceneTag tag of the scene
     * @returns the index of the scene
     */
    getSceneIndex: (sceneTag: string) => number;
    /**
     * [iOS Only]
     *
     * Resets the tracking of the AR session.
     *
     * @param resetTracking - determines if the tracking should be reset.
     * @param removeAnchors - determines if the existing anchors should be removed too.
     */
    /**
     * [iOS Only]
     *
     * Checks if the native ARSession is available and accessible.
     * Useful for verifying if the AR session has been successfully initialized
     * and exposed to the React Native bridge.
     *
     * @returns Promise resolving to a boolean indicating availability
     */
    _isNativeARSessionAvailable: () => Promise<boolean>;
    /**
     * [iOS Only]
     *
     * Resets the tracking of the AR session.
     *
     * @param resetTracking - determines if the tracking should be reset.
     * @param removeAnchors - determines if the existing anchors should be removed too.
     */
    _resetARSession: (resetTracking: any, removeAnchors: any) => void;
    /**
     * [iOS/ARKit 1.5+ Only]
     *
     * Allows the developer to offset the current world orgin
     * by the given transformation matrix. ie. if this is called twice with the
     * position [0, 0, 1], then current world origin will be at [0, 0, 2] from its
     * initial position (it's additive, not meant to replace the existing origin)
     *
     * @param worldOrigin - a dictionary that can contain a `position` and `rotation` key with an
     *  array containing 3 floats (note: rotation is in degrees).
     */
    _setWorldOrigin: (worldOrigin: ViroWorldOrigin) => void;
    /**
     * Host a local anchor to the cloud for cross-platform sharing.
     *
     * The anchor must already exist in the AR session (e.g., created from a hit test
     * or plane detection). Once hosted, the returned cloudAnchorId can be shared
     * with other devices to resolve the same anchor.
     *
     * @param anchorId - The local anchor ID to host (from ViroAnchor.anchorId)
     * @param ttlDays - Time-to-live in days (1-365). Default: 1 day.
     *                  Note: TTL > 1 requires keyless authorization on Google Cloud.
     * @returns Promise resolving to the hosting result with cloudAnchorId
     */
    _hostCloudAnchor: (anchorId: string, ttlDays?: number) => Promise<ViroHostCloudAnchorResult>;
    /**
     * Resolve a cloud anchor by its ID.
     *
     * Once resolved, the anchor will be added to the AR session and can be used
     * to place virtual content at the same real-world location as the original
     * hosted anchor (even on a different device).
     *
     * @param cloudAnchorId - The cloud anchor ID to resolve (from hostCloudAnchor result)
     * @returns Promise resolving to the anchor data
     */
    _resolveCloudAnchor: (cloudAnchorId: string) => Promise<ViroResolveCloudAnchorResult>;
    /**
     * Cancel all pending cloud anchor operations.
     * Use this when exiting a scene or when cloud operations are no longer needed.
     */
    _cancelCloudAnchorOperations: () => void;
    /**
     * Check if geospatial mode is supported on this device.
     *
     * @returns Promise resolving to support status
     */
    _isGeospatialModeSupported: () => Promise<ViroGeospatialSupportResult>;
    /**
     * Enable or disable geospatial mode.
     * When enabled, the session will track the device's position relative to the Earth.
     *
     * @param enabled - Whether to enable geospatial mode
     */
    _setGeospatialModeEnabled: (enabled: boolean) => void;
    /**
     * Get the current Earth tracking state.
     *
     * @returns Promise resolving to the current tracking state
     */
    _getEarthTrackingState: () => Promise<ViroEarthTrackingStateResult>;
    /**
     * Get the camera's current geospatial pose (latitude, longitude, altitude, etc.)
     *
     * @returns Promise resolving to the camera's geospatial pose
     */
    _getCameraGeospatialPose: () => Promise<ViroGeospatialPoseResult>;
    /**
     * Check VPS (Visual Positioning System) availability at a specific location.
     * VPS provides enhanced accuracy in supported locations.
     *
     * @param latitude - Latitude in degrees
     * @param longitude - Longitude in degrees
     * @returns Promise resolving to VPS availability status
     */
    _checkVPSAvailability: (latitude: number, longitude: number) => Promise<ViroVPSAvailabilityResult>;
    /**
     * Create a WGS84 geospatial anchor at the specified location.
     * The anchor is positioned using absolute coordinates on the WGS84 ellipsoid.
     *
     * @param latitude - Latitude in degrees
     * @param longitude - Longitude in degrees
     * @param altitude - Altitude in meters above the WGS84 ellipsoid
     * @param quaternion - Orientation quaternion [x, y, z, w] in EUS frame (optional, defaults to facing north)
     * @returns Promise resolving to the created anchor
     */
    _createGeospatialAnchor: (latitude: number, longitude: number, altitude: number, quaternion?: ViroQuaternion) => Promise<ViroCreateGeospatialAnchorResult>;
    /**
     * Create a terrain anchor at the specified location.
     * The anchor is positioned relative to the terrain surface.
     *
     * @param latitude - Latitude in degrees
     * @param longitude - Longitude in degrees
     * @param altitudeAboveTerrain - Altitude in meters above terrain
     * @param quaternion - Orientation quaternion [x, y, z, w] in EUS frame (optional)
     * @returns Promise resolving to the created anchor
     */
    _createTerrainAnchor: (latitude: number, longitude: number, altitudeAboveTerrain: number, quaternion?: ViroQuaternion) => Promise<ViroCreateGeospatialAnchorResult>;
    /**
     * Create a rooftop anchor at the specified location.
     * The anchor is positioned relative to a building rooftop.
     *
     * @param latitude - Latitude in degrees
     * @param longitude - Longitude in degrees
     * @param altitudeAboveRooftop - Altitude in meters above rooftop
     * @param quaternion - Orientation quaternion [x, y, z, w] in EUS frame (optional)
     * @returns Promise resolving to the created anchor
     */
    _createRooftopAnchor: (latitude: number, longitude: number, altitudeAboveRooftop: number, quaternion?: ViroQuaternion) => Promise<ViroCreateGeospatialAnchorResult>;
    /**
     * Remove a geospatial anchor from the session.
     *
     * @param anchorId - The ID of the anchor to remove
     */
    _removeGeospatialAnchor: (anchorId: string) => void;
    /**
     * Check if Scene Semantics mode is supported on this device.
     * Scene Semantics uses ML to classify each pixel in the camera feed
     * into categories like sky, building, tree, road, etc.
     *
     * @returns Promise resolving to support status
     */
    _isSemanticModeSupported: () => Promise<ViroSemanticSupportResult>;
    /**
     * Enable or disable Scene Semantics mode.
     * When enabled, the session will process each frame to generate
     * semantic labels for each pixel.
     *
     * @param enabled - Whether to enable semantic mode
     */
    _setSemanticModeEnabled: (enabled: boolean) => void;
    /**
     * Get the fraction of pixels for each semantic label in the current frame.
     * Returns a dictionary with label names as keys and fractions (0.0-1.0) as values.
     *
     * Available labels: unlabeled, sky, building, tree, road, sidewalk,
     * terrain, structure, object, vehicle, person, water
     *
     * @returns Promise resolving to semantic label fractions
     */
    _getSemanticLabelFractions: () => Promise<ViroSemanticLabelFractionsResult>;
    /**
     * Get the fraction of pixels for a specific semantic label.
     *
     * @param label - The semantic label name (e.g., "sky", "building", "road")
     * @returns Promise resolving to the fraction of pixels with that label
     */
    _getSemanticLabelFraction: (label: ViroSemanticLabel) => Promise<ViroSemanticLabelFractionResult>;
    /**
     * Check if monocular depth estimation is supported on this device.
     * Requires iOS 14.0+ with Neural Engine capabilities.
     *
     * @returns Promise resolving to support status
     */
    _isMonocularDepthSupported: () => Promise<ViroMonocularDepthSupportResult>;
    /**
     * Check if the monocular depth model has been downloaded.
     *
     * @returns Promise resolving to download status
     */
    _isMonocularDepthModelDownloaded: () => Promise<ViroMonocularDepthModelDownloadedResult>;
    /**
     * Enable or disable monocular depth estimation.
     * When enabled, depth will be estimated from the camera image using a neural network.
     * This provides depth-based occlusion on devices without LiDAR.
     *
     * Note: The model must be downloaded first using downloadMonocularDepthModel().
     *
     * @param enabled - Whether to enable monocular depth estimation
     */
    _setMonocularDepthEnabled: (enabled: boolean) => void;
    /**
     * Set the base URL for downloading the monocular depth model.
     * The full URL will be: baseURL/DepthPro.mlmodelc.zip
     *
     * @param baseURL - The base URL where the model is hosted
     */
    _setMonocularDepthModelURL: (baseURL: string) => void;
    /**
     * Download the monocular depth model if not already downloaded.
     * This is an asynchronous operation that downloads ~200MB.
     *
     * @returns Promise resolving to download result
     */
    _downloadMonocularDepthModel: () => Promise<ViroMonocularDepthDownloadResult>;
    /**
     * Set whether to prefer monocular depth estimation over LiDAR.
     * When enabled, monocular depth will be used even on devices with LiDAR.
     * Useful for:
     * - Consistency across device types
     * - Testing/comparison purposes
     * - Getting depth estimates beyond LiDAR's ~5m range
     *
     * @param prefer - Whether to prefer monocular depth over LiDAR
     */
    _setPreferMonocularDepth: (prefer: boolean) => void;
    /**
     * Check if monocular depth is preferred over LiDAR.
     *
     * @returns Promise resolving to preference status
     */
    _isPreferMonocularDepth: () => Promise<ViroMonocularDepthPreferenceResult>;
    /**
     * [iOS Only] Manually trigger a world map save.
     * Use this to ensure the world map is saved before navigating away,
     * or when you want to save at a specific point in time.
     *
     * Note: A sessionId must be set for this to work.
     *
     * @returns Promise resolving to the save result
     */
    _saveWorldMap: () => Promise<ViroSaveWorldMapResult>;
    /**
     * Set zoom using UIView transform (CGAffineTransform scale).
     * This scales the entire ARView visually, different from camera optical zoom.
     * Useful for quick visual zoom without camera hardware changes.
     *
     * @param zoomFactor - The scale factor (1.0 = normal, 2.0 = 2x scale, etc.)
     * @platform ios
     */
    _setViewZoom: (zoomFactor: number) => void;
    /**
     * Set render zoom using projection matrix scaling.
     * This modifies the camera's field of view and background texture to achieve
     * a real zoom effect that IS captured in screenshots, video recordings, and photos.
     *
     * Unlike setViewZoom (which uses UI scaling and isn't captured), setRenderZoom
     * modifies the actual render pipeline:
     * - Scales the projection matrix to narrow the field of view
     * - Crops the camera background texture to match
     * - Adjusts hit testing to account for the zoomed viewport
     *
     * @param zoomFactor - The zoom factor (1.0 = no zoom, 2.0 = 2x zoom, etc.)
     *                     Clamped to range [1.0, maxRenderZoom]
     * @platform ios
     */
    _setRenderZoom: (zoomFactor: number) => void;
    /**
     * Get the current render zoom factor.
     *
     * @returns Promise resolving to the current zoom factor
     * @platform ios
     */
    _getRenderZoom: () => Promise<ViroRenderZoomResult>;
    /**
     * Get the maximum render zoom factor.
     *
     * @returns Promise resolving to the maximum zoom factor
     * @platform ios
     */
    _getMaxRenderZoom: () => Promise<ViroMaxRenderZoomResult>;
    /**
     * Set the maximum render zoom factor.
     *
     * @param maxZoom - The maximum zoom factor (must be >= 1.0)
     * @platform ios
     */
    _setMaxRenderZoom: (maxZoom: number) => void;
    /**
     * Renders the Scene Views in the stack.
     *
     * @returns Array of rendered Scene views.
     */
    _renderSceneStackItems: () => React.JSX.Element[];
    arSceneNavigator: {
        push: (param1?: ViroScene | string, param2?: ViroScene) => void;
        pop: () => void;
        popN: (n: number) => void;
        jump: (param1?: ViroScene | string, param2?: ViroScene) => void;
        replace: (param1?: ViroScene | string, param2?: ViroScene) => void;
        startVideoRecording: (fileName: string, saveToCameraRoll: boolean, onError: (errorCode: number) => void) => void;
        stopVideoRecording: () => Promise<any>;
        takeScreenshot: (fileName: string, saveToCameraRoll: boolean) => Promise<any>;
        takeHighResolutionPhoto: (fileName: string, saveToCameraRoll: boolean) => Promise<any>;
        isNativeARSessionAvailable: () => Promise<boolean>;
        resetARSession: (resetTracking: any, removeAnchors: any) => void;
        setWorldOrigin: (worldOrigin: ViroWorldOrigin) => void;
        project: (point: Viro3DPoint) => Promise<any>;
        unproject: (point: Viro3DPoint) => Promise<any>;
        hostCloudAnchor: (anchorId: string, ttlDays?: number) => Promise<ViroHostCloudAnchorResult>;
        resolveCloudAnchor: (cloudAnchorId: string) => Promise<ViroResolveCloudAnchorResult>;
        cancelCloudAnchorOperations: () => void;
        isGeospatialModeSupported: () => Promise<ViroGeospatialSupportResult>;
        setGeospatialModeEnabled: (enabled: boolean) => void;
        getEarthTrackingState: () => Promise<ViroEarthTrackingStateResult>;
        getCameraGeospatialPose: () => Promise<ViroGeospatialPoseResult>;
        checkVPSAvailability: (latitude: number, longitude: number) => Promise<ViroVPSAvailabilityResult>;
        createGeospatialAnchor: (latitude: number, longitude: number, altitude: number, quaternion?: ViroQuaternion) => Promise<ViroCreateGeospatialAnchorResult>;
        createTerrainAnchor: (latitude: number, longitude: number, altitudeAboveTerrain: number, quaternion?: ViroQuaternion) => Promise<ViroCreateGeospatialAnchorResult>;
        createRooftopAnchor: (latitude: number, longitude: number, altitudeAboveRooftop: number, quaternion?: ViroQuaternion) => Promise<ViroCreateGeospatialAnchorResult>;
        removeGeospatialAnchor: (anchorId: string) => void;
        isSemanticModeSupported: () => Promise<ViroSemanticSupportResult>;
        setSemanticModeEnabled: (enabled: boolean) => void;
        getSemanticLabelFractions: () => Promise<ViroSemanticLabelFractionsResult>;
        getSemanticLabelFraction: (label: ViroSemanticLabel) => Promise<ViroSemanticLabelFractionResult>;
        isMonocularDepthSupported: () => Promise<ViroMonocularDepthSupportResult>;
        isMonocularDepthModelDownloaded: () => Promise<ViroMonocularDepthModelDownloadedResult>;
        setMonocularDepthEnabled: (enabled: boolean) => void;
        setMonocularDepthModelURL: (baseURL: string) => void;
        downloadMonocularDepthModel: () => Promise<ViroMonocularDepthDownloadResult>;
        setPreferMonocularDepth: (prefer: boolean) => void;
        isPreferMonocularDepth: () => Promise<ViroMonocularDepthPreferenceResult>;
        saveWorldMap: () => Promise<ViroSaveWorldMapResult>;
        setViewZoom: (zoomFactor: number) => void;
        setRenderZoom: (zoomFactor: number) => void;
        getRenderZoom: () => Promise<ViroRenderZoomResult>;
        getMaxRenderZoom: () => Promise<ViroMaxRenderZoomResult>;
        setMaxRenderZoom: (maxZoom: number) => void;
        viroAppProps: any;
    };
    sceneNavigator: {
        push: (param1?: ViroScene | string, param2?: ViroScene) => void;
        pop: () => void;
        popN: (n: number) => void;
        jump: (param1?: ViroScene | string, param2?: ViroScene) => void;
        replace: (param1?: ViroScene | string, param2?: ViroScene) => void;
        startVideoRecording: (fileName: string, saveToCameraRoll: boolean, onError: (errorCode: number) => void) => void;
        stopVideoRecording: () => Promise<any>;
        takeScreenshot: (fileName: string, saveToCameraRoll: boolean) => Promise<any>;
        takeHighResolutionPhoto: (fileName: string, saveToCameraRoll: boolean) => Promise<any>;
        isNativeARSessionAvailable: () => Promise<boolean>;
        resetARSession: (resetTracking: any, removeAnchors: any) => void;
        setWorldOrigin: (worldOrigin: ViroWorldOrigin) => void;
        project: (point: Viro3DPoint) => Promise<any>;
        unproject: (point: Viro3DPoint) => Promise<any>;
        hostCloudAnchor: (anchorId: string, ttlDays?: number) => Promise<ViroHostCloudAnchorResult>;
        resolveCloudAnchor: (cloudAnchorId: string) => Promise<ViroResolveCloudAnchorResult>;
        cancelCloudAnchorOperations: () => void;
        isGeospatialModeSupported: () => Promise<ViroGeospatialSupportResult>;
        setGeospatialModeEnabled: (enabled: boolean) => void;
        getEarthTrackingState: () => Promise<ViroEarthTrackingStateResult>;
        getCameraGeospatialPose: () => Promise<ViroGeospatialPoseResult>;
        checkVPSAvailability: (latitude: number, longitude: number) => Promise<ViroVPSAvailabilityResult>;
        createGeospatialAnchor: (latitude: number, longitude: number, altitude: number, quaternion?: ViroQuaternion) => Promise<ViroCreateGeospatialAnchorResult>;
        createTerrainAnchor: (latitude: number, longitude: number, altitudeAboveTerrain: number, quaternion?: ViroQuaternion) => Promise<ViroCreateGeospatialAnchorResult>;
        createRooftopAnchor: (latitude: number, longitude: number, altitudeAboveRooftop: number, quaternion?: ViroQuaternion) => Promise<ViroCreateGeospatialAnchorResult>;
        removeGeospatialAnchor: (anchorId: string) => void;
        isSemanticModeSupported: () => Promise<ViroSemanticSupportResult>;
        setSemanticModeEnabled: (enabled: boolean) => void;
        getSemanticLabelFractions: () => Promise<ViroSemanticLabelFractionsResult>;
        getSemanticLabelFraction: (label: ViroSemanticLabel) => Promise<ViroSemanticLabelFractionResult>;
        isMonocularDepthSupported: () => Promise<ViroMonocularDepthSupportResult>;
        isMonocularDepthModelDownloaded: () => Promise<ViroMonocularDepthModelDownloadedResult>;
        setMonocularDepthEnabled: (enabled: boolean) => void;
        setMonocularDepthModelURL: (baseURL: string) => void;
        downloadMonocularDepthModel: () => Promise<ViroMonocularDepthDownloadResult>;
        setPreferMonocularDepth: (prefer: boolean) => void;
        isPreferMonocularDepth: () => Promise<ViroMonocularDepthPreferenceResult>;
        saveWorldMap: () => Promise<ViroSaveWorldMapResult>;
        setViewZoom: (zoomFactor: number) => void;
        setRenderZoom: (zoomFactor: number) => void;
        getRenderZoom: () => Promise<ViroRenderZoomResult>;
        getMaxRenderZoom: () => Promise<ViroMaxRenderZoomResult>;
        setMaxRenderZoom: (maxZoom: number) => void;
        viroAppProps: any;
    };
    render(): React.JSX.Element;
}
export {};
